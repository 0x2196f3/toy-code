<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2048 â€“ Pure HTML/JS/CSS</title>
<style>
  *{box-sizing:border-box;margin:0;padding:0}
  body{font-family:Arial,Helvetica,sans-serif;background:#faf8ef;color:#776e65;
      display:flex;flex-direction:column;align-items:center;justify-content:flex-start;
      min-height:100vh;padding:20px}
  h1{margin-bottom:10px}
  #game{
      display:grid;
      grid-template-columns:repeat(4,80px);        /* fixed column width */
      gap:10px;
      padding:10px;
      background:#bbada0;
      border-radius:6px;
      width:calc(4*80px + 3*10px + 2*10px);      /* total width + padding */
  }
  .cell{
      background:#cdc1b4;
      border-radius:6px;
      height:80px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:2rem;
      font-weight:700;
      color:#776e65;
  }
  .cell[data-value="2"]{background:#eee4da;color:#776e65}
  .cell[data-value="4"]{background:#ede0c8;color:#776e65}
  .cell[data-value="8"]{background:#f2b179;color:#f9f6f2}
  .cell[data-value="16"]{background:#f59563;color:#f9f6f2}
  .cell[data-value="32"]{background:#f67c5f;color:#f9f6f2}
  .cell[data-value="64"]{background:#f65e3b;color:#f9f6f2}
  .cell[data-value="128"]{background:#edcf72;color:#f9f6f2}
  .cell[data-value="256"]{background:#edcc61;color:#f9f6f2}
  .cell[data-value="512"]{background:#edc850;color:#f9f6f2}
  .cell[data-value="1024"]{background:#edc53f;color:#f9f6f2}
  .cell[data-value="2048"]{background:#edc22e;color:#f9f6f2}
  #scores{margin:15px 0;display:flex;gap:20px}
  #scores div{background:#bbada0;border-radius:6px;padding:10px 20px;
      color:#f9f6f2;font-size:1.2rem;font-weight:700}
  #instructions{margin-top:10px;font-size:0.9rem}
  #overlay{
    position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(238,228,218,0.5);
    display:flex;align-items:center;justify-content:center;visibility:hidden}
  #overlay.show{visibility:visible}
  #overlay div{
    background:#f9f6f2;border-radius:6px;padding:30px 50px;text-align:center}
  #overlay button{margin-top:15px;padding:8px 15px;background:#8f7a66;color:#f9f6f2;
      border:none;border-radius:3px;font-size:1rem;cursor:pointer}
  #overlay button:hover{background:#776e65}
  @media(max-width:500px){
    .cell{height:70px;font-size:1.6rem}
  }
</style>
</head>
<body>
<h1>2048</h1>
<div id="scores">
  <div>Score: <span id="score">0</span></div>
  <div>High Score: <span id="highScore">0</span></div>
</div>
<div id="game"></div>
<div id="instructions">Use arrow keys to move tiles.</div>
<div id="overlay"><div><h2 id="gameOverText">Game Over!</h2><button id="restartBtn">Restart</button></div></div>

<script>
(() => {
  const SIZE = 4;
  const BOARD_KEY = '2048-board';
  const HIGH_KEY = '2048-highscore';
  let board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
  let score = 0;
  let highScore = localStorage.getItem(HIGH_KEY) || 0;
  const gameEl = document.getElementById('game');
  const scoreEl = document.getElementById('score');
  const highScoreEl = document.getElementById('highScore');
  const overlayEl = document.getElementById('overlay');
  const restartBtn = document.getElementById('restartBtn');

  function init() {
    board = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));
    score = 0;
    highScore = parseInt(highScore, 10) || 0;
    render();
    spawnTile();
    spawnTile();
    updateScore();
  }

  function spawnTile() {
    const empties = [];
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++)
        if (!board[r][c]) empties.push([r, c]);
    if (!empties.length) return;
    const [r, c] = empties[Math.floor(Math.random() * empties.length)];
    board[r][c] = Math.random() < 0.9 ? 2 : 4;
  }

  function render() {
    gameEl.innerHTML = '';
    for (let r = 0; r < SIZE; r++) {
      for (let c = 0; c < SIZE; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        const val = board[r][c];
        if (val) {
          cell.textContent = val;
          cell.setAttribute('data-value', val);
        } else {
          cell.textContent = '';
          cell.removeAttribute('data-value');
        }
        gameEl.appendChild(cell);
      }
    }
  }

  function updateScore() {
    scoreEl.textContent = score;
    if (score > highScore) {
      highScore = score;
      localStorage.setItem(HIGH_KEY, highScore);
    }
    highScoreEl.textContent = highScore;
  }

  function canMove() {
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE; c++)
        if (!board[r][c]) return true;
    for (let r = 0; r < SIZE; r++)
      for (let c = 0; c < SIZE - 1; c++)
        if (board[r][c] === board[r][c + 1]) return true;
    for (let c = 0; c < SIZE; c++)
      for (let r = 0; r < SIZE - 1; r++)
        if (board[r][c] === board[r + 1][c]) return true;
    return false;
  }

  function mergeLine(line) {
    const filtered = line.filter(n => n);
    const merged = [];
    let i = 0;
    while (i < filtered.length) {
      if (i + 1 < filtered.length && filtered[i] === filtered[i + 1]) {
        merged.push(filtered[i] * 2);
        score += filtered[i] * 2;
        i += 2;
      } else {
        merged.push(filtered[i]);
        i += 1;
      }
    }
    while (merged.length < SIZE) merged.push(0);
    return merged;
  }

  function move(direction) {
    let moved = false;
    const newBoard = Array.from({ length: SIZE }, () => Array(SIZE).fill(0));

    if (direction === 'left') {
      for (let r = 0; r < SIZE; r++) {
        const line = board[r];
        const merged = mergeLine(line);
        if (!arraysEqual(line, merged)) moved = true;
        newBoard[r] = merged;
      }
    } else if (direction === 'right') {
      for (let r = 0; r < SIZE; r++) {
        const line = [...board[r]].reverse();
        const merged = mergeLine(line).reverse();
        if (!arraysEqual([...board[r]], merged)) moved = true;
        newBoard[r] = merged;
      }
    } else if (direction === 'up') {
      for (let c = 0; c < SIZE; c++) {
        const line = [];
        for (let r = 0; r < SIZE; r++) line.push(board[r][c]);
        const merged = mergeLine(line);
        for (let r = 0; r < SIZE; r++) {
          if (newBoard[r][c] !== merged[r]) moved = true;
          newBoard[r][c] = merged[r];
        }
      }
    } else if (direction === 'down') {
      for (let c = 0; c < SIZE; c++) {
        const line = [];
        for (let r = SIZE - 1; r >= 0; r--) line.push(board[r][c]);
        const merged = mergeLine(line).reverse();
        for (let r = 0; r < SIZE; r++) {
          if (newBoard[r][c] !== merged[r]) moved = true;
          newBoard[r][c] = merged[r];
        }
      }
    }

    if (moved) {
      board = newBoard;
      spawnTile();
      render();
      updateScore();
      if (!canMove()) showGameOver();
    }
  }

  function arraysEqual(a, b) {
    for (let i = 0; i < a.length; i++)
      if (a[i] !== b[i]) return false;
    return true;
  }

  function showGameOver() {
    overlayEl.classList.add('show');
  }

  function hideGameOver() {
    overlayEl.classList.remove('show');
  }

  document.addEventListener('keydown', e => {
    switch (e.key) {
      case 'ArrowUp': move('up'); break;
      case 'ArrowDown': move('down'); break;
      case 'ArrowLeft': move('left'); break;
      case 'ArrowRight': move('right'); break;
    }
  });

  restartBtn.addEventListener('click', () => {
    hideGameOver();
    init();
  });

  init();
})();
</script>
</body>
</html>
