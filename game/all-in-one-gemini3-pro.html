<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>7-in-1 Game Console</title>
<style>
    body { margin: 0; padding: 0; background: #202020; color: #fff; font-family: 'Courier New', Courier, monospace; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; overflow: hidden; }
    #game-container { position: relative; width: 400px; height: 600px; background: #000; border: 4px solid #444; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
    canvas { display: block; width: 100%; height: 100%; }
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; align-items: center; justify-content: center; }
    #menu { background: rgba(0,0,0,0.9); width: 100%; height: 100%; position: absolute; top: 0; left: 0; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding-top: 50px; pointer-events: auto; }
    button { background: #333; color: #fff; border: 2px solid #fff; padding: 10px 20px; margin: 5px; cursor: pointer; font-family: inherit; font-size: 16px; width: 200px; transition: 0.2s; }
    button:hover { background: #fff; color: #000; }
    #back-btn { position: absolute; top: 10px; right: 10px; z-index: 100; padding: 5px 10px; width: auto; font-size: 12px; display: none; background: #f00; border-color: #f00; }
    #score-board { position: absolute; top: 10px; left: 10px; z-index: 99; font-size: 20px; font-weight: bold; text-shadow: 1px 1px 0 #000; pointer-events: none; display: none; }
    .hidden { display: none !important; }
</style>
</head>
<body>

<div id="game-container">
    <canvas id="canvas" width="400" height="600"></canvas>
    <div id="score-board">Score: 0</div>
    <button id="back-btn" onclick="showMenu()">EXIT</button>
    <div id="menu">
        <h1>ARCADE</h1>
        <button onclick="startGame('2048')">2048</button>
        <button onclick="startGame('aircraft')">Aircraft War</button>
        <button onclick="startGame('snake')">Snake</button>
        <button onclick="startGame('tetris')">Tetris</button>
        <button onclick="startGame('breakout')">Breakout</button>
        <button onclick="startGame('flappy')">Flappy Bird</button>
        <button onclick="startGame('minesweeper')">Minesweeper</button>
    </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const menu = document.getElementById('menu');
const backBtn = document.getElementById('back-btn');
const scoreEl = document.getElementById('score-board');

let gameLoopId;
let activeGame = null;
let score = 0;

const CW = canvas.width;
const CH = canvas.height;

function showMenu() {
    cancelAnimationFrame(gameLoopId);
    activeGame = null;
    menu.classList.remove('hidden');
    backBtn.style.display = 'none';
    scoreEl.style.display = 'none';
    ctx.clearRect(0, 0, CW, CH);
}

function startGame(type) {
    menu.classList.add('hidden');
    backBtn.style.display = 'block';
    scoreEl.style.display = 'block';
    score = 0;
    updateScore(0);
    
    switch(type) {
        case '2048': activeGame = new Game2048(); break;
        case 'aircraft': activeGame = new AircraftWar(); break;
        case 'snake': activeGame = new Snake(); break;
        case 'tetris': activeGame = new Tetris(); break;
        case 'breakout': activeGame = new Breakout(); break;
        case 'flappy': activeGame = new FlappyBird(); break;
        case 'minesweeper': activeGame = new Minesweeper(); break;
    }
    
    if(activeGame) {
        activeGame.init();
        loop();
    }
}

function updateScore(val) {
    score = val;
    scoreEl.innerText = 'Score: ' + score;
}

function loop() {
    if(!activeGame) return;
    ctx.clearRect(0, 0, CW, CH);
    activeGame.update();
    activeGame.draw();
    gameLoopId = requestAnimationFrame(loop);
}

document.addEventListener('keydown', e => {
    if(activeGame && activeGame.onKey) activeGame.onKey(e);
});

canvas.addEventListener('mousedown', e => {
    if(activeGame && activeGame.onClick) {
        const rect = canvas.getBoundingClientRect();
        activeGame.onClick(e.clientX - rect.left, e.clientY - rect.top, e.button);
    }
});

canvas.addEventListener('contextmenu', e => {
    e.preventDefault();
    return false;
});

class Game2048 {
    constructor() {
        this.grid = [];
        this.size = 4;
        this.cellSize = 90;
        this.padding = 10;
        this.offsetX = (CW - (this.size * (this.cellSize + this.padding) + this.padding)) / 2;
        this.offsetY = (CH - (this.size * (this.cellSize + this.padding) + this.padding)) / 2;
        this.over = false;
    }
    init() {
        this.grid = Array(4).fill().map(() => Array(4).fill(0));
        this.spawn();
        this.spawn();
    }
    spawn() {
        let empty = [];
        for(let r=0; r<4; r++) for(let c=0; c<4; c++) if(this.grid[r][c] === 0) empty.push({r,c});
        if(empty.length) {
            let p = empty[Math.floor(Math.random() * empty.length)];
            this.grid[p.r][p.c] = Math.random() < 0.9 ? 2 : 4;
        }
    }
    update() {}
    draw() {
        ctx.fillStyle = '#bbada0';
        ctx.fillRect(0,0,CW,CH);
        for(let r=0; r<4; r++) {
            for(let c=0; c<4; c++) {
                let val = this.grid[r][c];
                let x = this.offsetX + c * (this.cellSize + this.padding) + this.padding;
                let y = this.offsetY + r * (this.cellSize + this.padding) + this.padding;
                ctx.fillStyle = this.getColor(val);
                ctx.fillRect(x, y, this.cellSize, this.cellSize);
                if(val) {
                    ctx.fillStyle = val > 4 ? '#f9f6f2' : '#776e65';
                    ctx.font = 'bold ' + (val > 100 ? 30 : 40) + 'px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(val, x + this.cellSize/2, y + this.cellSize/2);
                }
            }
        }
        if(this.over) this.drawGameOver();
    }
    getColor(v) {
        const map = {0:'#ccc0b3',2:'#eee4da',4:'#ede0c8',8:'#f2b179',16:'#f59563',32:'#f67c5f',64:'#f65e3b',128:'#edcf72',256:'#edcc61',512:'#edc850',1024:'#edc53f',2048:'#edc22e'};
        return map[v] || '#3c3a32';
    }
    onKey(e) {
        if(this.over) return;
        let moved = false;
        let oldGrid = JSON.stringify(this.grid);
        if(e.key === 'ArrowUp') moved = this.move(0, -1);
        else if(e.key === 'ArrowDown') moved = this.move(0, 1);
        else if(e.key === 'ArrowLeft') moved = this.move(-1, 0);
        else if(e.key === 'ArrowRight') moved = this.move(1, 0);
        if(JSON.stringify(this.grid) !== oldGrid) {
            this.spawn();
            updateScore(this.grid.flat().reduce((a,b)=>a+b,0));
            if(this.checkOver()) this.over = true;
        }
    }
    move(dx, dy) {
        let rotated = false;
        if(dx !== 0) { this.rotateGrid(); rotated = true; }
        let success = false;
        for(let r=0; r<4; r++) {
            let row = this.grid[r].filter(x => x);
            if(dy > 0 || dx > 0) row.reverse();
            for(let i=0; i<row.length-1; i++) {
                if(row[i] === row[i+1]) { row[i] *= 2; row[i+1] = 0; }
            }
            row = row.filter(x => x);
            while(row.length < 4) row.push(0);
            if(dy > 0 || dx > 0) row.reverse();
            this.grid[r] = row;
        }
        if(rotated) { this.rotateGrid(); this.rotateGrid(); this.rotateGrid(); }
        return true;
    }
    rotateGrid() {
        this.grid = this.grid[0].map((val, index) => this.grid.map(row => row[index]).reverse());
    }
    checkOver() {
        if(this.grid.flat().includes(0)) return false;
        for(let r=0; r<4; r++) for(let c=0; c<4; c++) {
            if(c<3 && this.grid[r][c] === this.grid[r][c+1]) return false;
            if(r<3 && this.grid[r][c] === this.grid[r+1][c]) return false;
        }
        return true;
    }
    drawGameOver() {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0,0,CW,CH);
        ctx.fillStyle = '#fff';
        ctx.font = '40px Arial';
        ctx.fillText('Game Over', CW/2, CH/2);
    }
}

class AircraftWar {
    constructor() {
        this.p = {x: CW/2, y: CH-50, w: 30, h: 30};
        this.bullets = [];
        this.enemies = [];
        this.tick = 0;
        this.over = false;
    }
    init() {}
    update() {
        if(this.over) return;
        this.tick++;
        if(this.tick % 5 === 0) this.bullets.push({x: this.p.x, y: this.p.y, w: 4, h: 10});
        if(this.tick % 60 === 0) this.enemies.push({x: Math.random()*(CW-40)+20, y: -20, w: 30, h: 30, hp: 2});
        
        this.bullets.forEach(b => b.y -= 7);
        this.bullets = this.bullets.filter(b => b.y > -20);
        
        this.enemies.forEach(e => e.y += 2);
        
        for(let i=this.enemies.length-1; i>=0; i--) {
            let e = this.enemies[i];
            if(e.y > CH) { this.enemies.splice(i,1); continue; }
            if(Math.abs(e.x - this.p.x) < 20 && Math.abs(e.y - this.p.y) < 20) this.over = true;
            for(let j=this.bullets.length-1; j>=0; j--) {
                let b = this.bullets[j];
                if(b.x > e.x - e.w/2 && b.x < e.x + e.w/2 && b.y < e.y + e.h/2 && b.y > e.y - e.h/2) {
                    e.hp--;
                    this.bullets.splice(j,1);
                    if(e.hp <= 0) {
                        this.enemies.splice(i,1);
                        updateScore(score + 10);
                        break;
                    }
                }
            }
        }
    }
    draw() {
        ctx.fillStyle = '#000033';
        ctx.fillRect(0,0,CW,CH);
        
        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.moveTo(this.p.x, this.p.y - 15);
        ctx.lineTo(this.p.x - 15, this.p.y + 15);
        ctx.lineTo(this.p.x + 15, this.p.y + 15);
        ctx.fill();
        
        ctx.fillStyle = '#ff0';
        this.bullets.forEach(b => ctx.fillRect(b.x-2, b.y, b.w, b.h));
        
        ctx.fillStyle = '#f00';
        this.enemies.forEach(e => {
            ctx.beginPath();
            ctx.moveTo(e.x, e.y+15);
            ctx.lineTo(e.x-15, e.y-15);
            ctx.lineTo(e.x+15, e.y-15);
            ctx.fill();
        });
        
        if(this.over) {
            ctx.fillStyle = '#fff';
            ctx.font = '30px Courier';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CW/2, CH/2);
        }
    }
    onKey(e) {
        if(this.over) return;
        const s = 15;
        if(e.key === 'ArrowLeft') this.p.x = Math.max(15, this.p.x - s);
        if(e.key === 'ArrowRight') this.p.x = Math.min(CW-15, this.p.x + s);
        if(e.key === 'ArrowUp') this.p.y = Math.max(15, this.p.y - s);
        if(e.key === 'ArrowDown') this.p.y = Math.min(CH-15, this.p.y + s);
    }
}

class Snake {
    constructor() {
        this.s = 20;
        this.snake = [];
        this.food = {};
        this.dir = {x:0, y:0};
        this.nextDir = {x:0, y:0};
        this.over = false;
        this.speed = 10;
        this.tick = 0;
    }
    init() {
        this.snake = [{x:10, y:10}, {x:9, y:10}, {x:8, y:10}];
        this.dir = {x:1, y:0};
        this.nextDir = {x:1, y:0};
        this.placeFood();
    }
    placeFood() {
        this.food = {x: Math.floor(Math.random()*(CW/this.s)), y: Math.floor(Math.random()*(CH/this.s))};
    }
    update() {
        if(this.over) return;
        this.tick++;
        if(this.tick % 8 !== 0) return;
        
        this.dir = this.nextDir;
        let head = {x: this.snake[0].x + this.dir.x, y: this.snake[0].y + this.dir.y};
        
        if(head.x < 0 || head.x >= CW/this.s || head.y < 0 || head.y >= CH/this.s || this.snake.some(s => s.x === head.x && s.y === head.y)) {
            this.over = true;
            return;
        }
        
        this.snake.unshift(head);
        if(head.x === this.food.x && head.y === this.food.y) {
            updateScore(score + 1);
            this.placeFood();
        } else {
            this.snake.pop();
        }
    }
    draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,CW,CH);
        ctx.fillStyle = '#0f0';
        this.snake.forEach(p => ctx.fillRect(p.x*this.s, p.y*this.s, this.s-1, this.s-1));
        ctx.fillStyle = '#f00';
        ctx.fillRect(this.food.x*this.s, this.food.y*this.s, this.s-1, this.s-1);
        
        if(this.over) {
            ctx.fillStyle = '#fff';
            ctx.font = '30px Courier';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CW/2, CH/2);
        }
    }
    onKey(e) {
        if(e.key === 'ArrowUp' && this.dir.y === 0) this.nextDir = {x:0, y:-1};
        if(e.key === 'ArrowDown' && this.dir.y === 0) this.nextDir = {x:0, y:1};
        if(e.key === 'ArrowLeft' && this.dir.x === 0) this.nextDir = {x:-1, y:0};
        if(e.key === 'ArrowRight' && this.dir.x === 0) this.nextDir = {x:1, y:0};
    }
}

class Tetris {
    constructor() {
        this.cols = 10;
        this.rows = 20;
        this.bs = 30; // 300x600 board
        this.offsetX = (CW - 300)/2;
        this.board = [];
        this.curr = null;
        this.tick = 0;
        this.over = false;
        this.shapes = [
            [[1,1,1,1]], 
            [[1,1],[1,1]], 
            [[0,1,0],[1,1,1]], 
            [[1,0,0],[1,1,1]], 
            [[0,0,1],[1,1,1]], 
            [[0,1,1],[1,1,0]], 
            [[1,1,0],[0,1,1]]
        ];
        this.colors = ['cyan','yellow','purple','blue','orange','green','red'];
    }
    init() {
        this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
        this.newPiece();
    }
    newPiece() {
        let id = Math.floor(Math.random()*this.shapes.length);
        this.curr = { m: this.shapes[id], x: 3, y: 0, c: id+1 };
        if(this.collide(0,0)) this.over = true;
    }
    collide(ox, oy, m = this.curr.m) {
        for(let r=0; r<m.length; r++) {
            for(let c=0; c<m[r].length; c++) {
                if(m[r][c] && (this.curr.y + r + oy >= this.rows || this.curr.x + c + ox < 0 || this.curr.x + c + ox >= this.cols || (this.curr.y + r + oy >= 0 && this.board[this.curr.y + r + oy][this.curr.x + c + ox]))) return true;
            }
        }
        return false;
    }
    rotate() {
        let m = this.curr.m;
        let nm = m[0].map((val, index) => m.map(row => row[index]).reverse());
        if(!this.collide(0,0,nm)) this.curr.m = nm;
    }
    update() {
        if(this.over) return;
        this.tick++;
        if(this.tick % 20 === 0) {
            if(!this.collide(0, 1)) {
                this.curr.y++;
            } else {
                this.freeze();
                this.clearLines();
                this.newPiece();
            }
        }
    }
    freeze() {
        for(let r=0; r<this.curr.m.length; r++) {
            for(let c=0; c<this.curr.m[r].length; c++) {
                if(this.curr.m[r][c]) {
                    let by = this.curr.y + r;
                    if(by >= 0) this.board[by][this.curr.x + c] = this.curr.c;
                }
            }
        }
    }
    clearLines() {
        for(let r=this.rows-1; r>=0; r--) {
            if(this.board[r].every(v => v !== 0)) {
                this.board.splice(r, 1);
                this.board.unshift(Array(this.cols).fill(0));
                updateScore(score + 100);
                r++;
            }
        }
    }
    draw() {
        ctx.fillStyle = '#111';
        ctx.fillRect(0,0,CW,CH);
        ctx.fillStyle = '#222';
        ctx.fillRect(this.offsetX, 0, 300, 600);
        
        for(let r=0; r<this.rows; r++) {
            for(let c=0; c<this.cols; c++) {
                if(this.board[r][c]) this.drawBlock(c, r, this.colors[this.board[r][c]-1]);
            }
        }
        if(this.curr) {
            for(let r=0; r<this.curr.m.length; r++) {
                for(let c=0; c<this.curr.m[r].length; c++) {
                    if(this.curr.m[r][c]) this.drawBlock(this.curr.x + c, this.curr.y + r, this.colors[this.curr.c-1]);
                }
            }
        }
        if(this.over) {
            ctx.fillStyle = '#fff';
            ctx.textAlign = 'center';
            ctx.fillText('GAME OVER', CW/2, CH/2);
        }
    }
    drawBlock(x, y, c) {
        ctx.fillStyle = c;
        ctx.fillRect(this.offsetX + x*this.bs, y*this.bs, this.bs, this.bs);
        ctx.strokeStyle = '#000';
        ctx.strokeRect(this.offsetX + x*this.bs, y*this.bs, this.bs, this.bs);
    }
    onKey(e) {
        if(this.over) return;
        if(e.key === 'ArrowLeft' && !this.collide(-1, 0)) this.curr.x--;
        if(e.key === 'ArrowRight' && !this.collide(1, 0)) this.curr.x++;
        if(e.key === 'ArrowDown' && !this.collide(0, 1)) this.curr.y++;
        if(e.key === 'ArrowUp') this.rotate();
    }
}

class Breakout {
    constructor() {
        this.pad = {w:80, h:10, x:160};
        this.ball = {x:200, y:300, r:6, dx:4, dy:-4};
        this.bricks = [];
        this.cols = 5;
        this.rows = 6;
        this.over = false;
        this.won = false;
    }
    init() {
        for(let r=0; r<this.rows; r++) {
            for(let c=0; c<this.cols; c++) {
                this.bricks.push({x: c*80 + 5, y: r*25 + 40, w: 70, h: 20, s: 1});
            }
        }
    }
    update() {
        if(this.over || this.won) return;
        this.ball.x += this.ball.dx;
        this.ball.y += this.ball.dy;
        
        if(this.ball.x + this.ball.r > CW || this.ball.x - this.ball.r < 0) this.ball.dx *= -1;
        if(this.ball.y - this.ball.r < 0) this.ball.dy *= -1;
        if(this.ball.y + this.ball.r > CH) this.over = true;
        
        if(this.ball.y + this.ball.r > CH - 30 && this.ball.x > this.pad.x && this.ball.x < this.pad.x + this.pad.w) {
            this.ball.dy = -Math.abs(this.ball.dy);
        }
        
        for(let i=0; i<this.bricks.length; i++) {
            let b = this.bricks[i];
            if(b.s && this.ball.x > b.x && this.ball.x < b.x + b.w && this.ball.y > b.y && this.ball.y < b.y + b.h) {
                this.ball.dy *= -1;
                b.s = 0;
                updateScore(score + 10);
            }
        }
        if(this.bricks.every(b => !b.s)) this.won = true;
    }
    draw() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0,0,CW,CH);
        ctx.fillStyle = '#00f';
        ctx.fillRect(this.pad.x, CH-30, this.pad.w, this.pad.h);
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(this.ball.x, this.ball.y, this.ball.r, 0, Math.PI*2);
        ctx.fill();
        
        this.bricks.forEach(b => {
            if(b.s) {
                ctx.fillStyle = '#d03';
                ctx.fillRect(b.x, b.y, b.w, b.h);
            }
        });
        
        if(this.over) {
            ctx.fillStyle = '#fff';
            ctx.fillText('GAME OVER', CW/2, CH/2);
        }
        if(this.won) {
            ctx.fillStyle = '#0f0';
            ctx.fillText('YOU WIN', CW/2, CH/2);
        }
    }
    onKey(e) {
        if(e.key === 'ArrowLeft') this.pad.x = Math.max(0, this.pad.x - 30);
        if(e.key === 'ArrowRight') this.pad.x = Math.min(CW-this.pad.w, this.pad.x + 30);
    }
}

class FlappyBird {
    constructor() {
        this.bird = {y: CH/2, v: 0, r: 15};
        this.pipes = [];
        this.g = 0.5;
        this.jump = -8;
        this.tick = 0;
        this.over = false;
        this.gap = 140;
    }
    init() {}
    update() {
        if(this.over) return;
        this.tick++;
        this.bird.v += this.g;
        this.bird.y += this.bird.v;
        
        if(this.tick % 90 === 0) {
            let h = Math.random() * (CH - this.gap - 100) + 50;
            this.pipes.push({x: CW, y: h, w: 50});
        }
        
        this.pipes.forEach(p => p.x -= 3);
        this.pipes = this.pipes.filter(p => p.x > -50);
        
        if(this.bird.y < 0 || this.bird.y > CH) this.over = true;
        
        this.pipes.forEach(p => {
            if(p.x < 50 + this.bird.r && p.x + p.w > 50 - this.bird.r) {
                if(this.bird.y - this.bird.r < p.y || this.bird.y + this.bird.r > p.y + this.gap) {
                    this.over = true;
                }
            }
            if(p.x === 47) updateScore(score + 1);
        });
    }
    draw() {
        ctx.fillStyle = '#70c5ce';
        ctx.fillRect(0,0,CW,CH);
        
        ctx.fillStyle = '#0f0';
        this.pipes.forEach(p => {
            ctx.fillRect(p.x, 0, p.w, p.y);
            ctx.fillRect(p.x, p.y + this.gap, p.w, CH - (p.y + this.gap));
        });
        
        ctx.fillStyle = '#ff0';
        ctx.beginPath();
        ctx.arc(50, this.bird.y, this.bird.r, 0, Math.PI*2);
        ctx.fill();
        
        if(this.over) {
            ctx.fillStyle = '#f00';
            ctx.fillText('CRASHED', CW/2, CH/2);
        }
    }
    onKey(e) {
        if(!this.over && e.code === 'Space') this.bird.v = this.jump;
    }
    onClick() {
        if(!this.over) this.bird.v = this.jump;
    }
}

class Minesweeper {
    constructor() {
        this.grid = [];
        this.cols = 10;
        this.rows = 15;
        this.bs = 40;
        this.bombs = 20;
        this.over = false;
        this.won = false;
        this.firstClick = true;
    }
    init() {
        this.grid = Array(this.rows).fill().map(() => Array(this.cols).fill().map(() => ({b: false, r: false, f: false, n: 0})));
    }
    placeBombs(noR, noC) {
        let placed = 0;
        while(placed < this.bombs) {
            let r = Math.floor(Math.random() * this.rows);
            let c = Math.floor(Math.random() * this.cols);
            if(!this.grid[r][c].b && (Math.abs(r-noR)>1 || Math.abs(c-noC)>1)) {
                this.grid[r][c].b = true;
                placed++;
            }
        }
        for(let r=0; r<this.rows; r++) {
            for(let c=0; c<this.cols; c++) {
                if(!this.grid[r][c].b) {
                    let n = 0;
                    for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) {
                        if(r+i>=0 && r+i<this.rows && c+j>=0 && c+j<this.cols && this.grid[r+i][c+j].b) n++;
                    }
                    this.grid[r][c].n = n;
                }
            }
        }
    }
    update() {
        if(!this.over && !this.won) {
            let revealed = this.grid.flat().filter(c => c.r).length;
            if(revealed === this.rows*this.cols - this.bombs) this.won = true;
        }
    }
    draw() {
        ctx.fillStyle = '#ccc';
        ctx.fillRect(0,0,CW,CH);
        for(let r=0; r<this.rows; r++) {
            for(let c=0; c<this.cols; c++) {
                let cell = this.grid[r][c];
                let x = c*this.bs, y = r*this.bs;
                ctx.strokeStyle = '#888';
                ctx.strokeRect(x,y,this.bs,this.bs);
                
                if(!cell.r) {
                    ctx.fillStyle = '#999';
                    ctx.fillRect(x+1, y+1, this.bs-2, this.bs-2);
                    if(cell.f) {
                        ctx.fillStyle = '#f00';
                        ctx.font = '20px Arial';
                        ctx.fillText('F', x + this.bs/2, y + this.bs/2);
                    }
                } else {
                    ctx.fillStyle = '#eee';
                    ctx.fillRect(x+1, y+1, this.bs-2, this.bs-2);
                    if(cell.b) {
                        ctx.fillStyle = '#000';
                        ctx.beginPath();
                        ctx.arc(x+this.bs/2, y+this.bs/2, 10, 0, Math.PI*2);
                        ctx.fill();
                    } else if(cell.n > 0) {
                        ctx.fillStyle = ['#00f','#080','#f00','#008'][cell.n-1] || '#000';
                        ctx.font = '20px Arial';
                        ctx.fillText(cell.n, x+this.bs/2, y+this.bs/2);
                    }
                }
            }
        }
        if(this.over) { ctx.fillStyle='rgba(255,0,0,0.5)'; ctx.fillRect(0,0,CW,CH); ctx.fillStyle='#fff'; ctx.fillText('BOOM', CW/2, CH/2); }
        if(this.won) { ctx.fillStyle='rgba(0,255,0,0.5)'; ctx.fillRect(0,0,CW,CH); ctx.fillStyle='#fff'; ctx.fillText('CLEAR', CW/2, CH/2); }
    }
    onClick(x, y, btn) {
        if(this.over || this.won) return;
        let c = Math.floor(x/this.bs);
        let r = Math.floor(y/this.bs);
        if(c < 0 || c >= this.cols || r < 0 || r >= this.rows) return;
        
        let cell = this.grid[r][c];
        if(btn === 2) {
            if(!cell.r) cell.f = !cell.f;
        } else {
            if(cell.f) return;
            if(this.firstClick) {
                this.placeBombs(r,c);
                this.firstClick = false;
            }
            this.reveal(r, c);
        }
    }
    reveal(r, c) {
        if(r<0||r>=this.rows||c<0||c>=this.cols||this.grid[r][c].r||this.grid[r][c].f) return;
        let cell = this.grid[r][c];
        cell.r = true;
        if(cell.b) { this.over = true; return; }
        if(cell.n === 0) {
            for(let i=-1; i<=1; i++) for(let j=-1; j<=1; j++) this.reveal(r+i, c+j);
        }
    }
}
</script>
</body>
</html>